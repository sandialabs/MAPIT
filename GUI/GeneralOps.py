from MAPIT.GUI import ThreadTools, StatsPanelOps
from PySide2 import QtCore,QtWidgets, QtGui
import os
import numpy as np
from pathlib import Path
import sys
import csv
from scipy.io import savemat, loadmat
import pickle
import glob
import queue
import json


def SaveStats(self, AnalysisData, GUIparams):
    """
            This function exports
            results generated by MAPIT
            to (potentially multiple)
            .csv files.
    """

    #create a directory for output if doesnt exist
    outdir = os.path.join(Path(sys.argv[0]).resolve().parents[1], 'MAPIT_Output')
    if not os.path.isdir(outdir):
      os.makedirs(outdir)

    self.PB.setMaximum(0)
    self.PB.setMinimum(0)
    #self.StatDlg.UpdateDispText('Saving Data')
    self.PB.setFormat('Saving data')
    QtCore.QCoreApplication.instance().processEvents()


    #TODO: add output format options for tests as
    # currently only different formats for
    # process data is supported

    QtCore.QCoreApplication.instance().processEvents(
    )  #makes sure the GUI doesnt look frozen

    if hasattr(AnalysisData,'MUF'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_MUF.csv'),
        AnalysisData.MUF.T,
        delimiter=',')

    if hasattr(AnalysisData,'CUMUF'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_CUMUF.csv'),
        AnalysisData.CUMUF.T,
        delimiter=',')


    if hasattr(AnalysisData,'SEMUF'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_SEID.csv'),
        AnalysisData.SEMUF.T,
        delimiter=',')


    if hasattr(AnalysisData,'SITMUF'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_SITMUF.csv'),
        AnalysisData.SITMUF.T,
        delimiter=',')

    if hasattr(AnalysisData,'Page'):
      np.savetxt(
        os.path.join(outdir,GUIparams.TestType+'_SITMUF_Page.csv'),
        AnalysisData.Page.T,
        delimiter=',')
    # print observed data
    #future TODO
    #will require some extra thought for
    #how to handle non-uniformly sampled data
    #save to .xlsx? separate .csv for time?

    CheckPrint = QtWidgets.QMessageBox(self)
    CheckPrint.setText('Save observed data?')
    CheckPrint.setInformativeText(
        'Observed data is the user supplied ground truth with applied specified errors'
    )
    CheckPrint.setStandardButtons(QtWidgets.QMessageBox.Yes
                                  | QtWidgets.QMessageBox.No)

    #this reorders the buttons from the default no,yes to yes,no
    hlay = CheckPrint.findChild(QtWidgets.QHBoxLayout)
    litem = hlay.takeAt(1)
    w = litem.widget()
    hlay.addWidget(w)
    CPE = CheckPrint.exec_()



    ck1 = self.CB_MUF.isChecked() + self.CB_SMUF.isChecked(
    ) + self.CB_SITMUF.isChecked() + self.CB_PAGE.isChecked() +\
    self.CB_CUMUF.isChecked()



    # [iter, location, timestep, element]
    #if labels exist use them to help
    #write the name of the output files
    if QtWidgets.QMessageBox.Yes == CPE:

      getOutType = QtWidgets.QMessageBox()
      getOutType.setText('Select output format.')
      getOutType.setInformativeText(
        'Order by iteration: Group data into run iteration, better for manual human analysis \n \n' \
        'Order by location: Group data by location, better for importing into secondary analytical pipelines')
    


      buttonCSVL = getOutType.addButton('.csv: by location',QtWidgets.QMessageBox.ResetRole) #this is arbitrary, but if accept and reject roles aren't present then the red X to close the dialog wont work
      buttonCSVI = getOutType.addButton('.csv: by iteration',QtWidgets.QMessageBox.ApplyRole)
      buttonNPZ = getOutType.addButton('.npz archive',QtWidgets.QMessageBox.RejectRole)
      buttonMAT = getOutType.addButton('.mat archive', QtWidgets.QMessageBox.NoRole)
      buttonPKL = getOutType.addButton('.pkl archive', QtWidgets.QMessageBox.NoRole)


      CT = getOutType.exec_()
      
      IT = AnalysisData.inputAppliedError[0].shape[0]
      if getOutType.clickedButton() == buttonCSVL:
        
        headers = np.empty((IT+1,),dtype='U13')
        headers[0] = 'Time'
        for J in range(IT):
          headers[J+1] = 'Iteration ' + str(J)

        

        #by run or by location
        #by location here
        for J in range(len(AnalysisData.inputAppliedError)):
          holder = headers.reshape((-1,1))
          holder = np.concatenate((holder,
            np.concatenate((AnalysisData.rawInputTimes[J].reshape((1,-1)),np.squeeze(AnalysisData.inputAppliedError[J])),axis=0,dtype='U13')),axis=1)

          np.savetxt(
            os.path.join(outdir,GUIparams.TestType+'_Input'+str(J)+'.csv'),
            holder.T,
            delimiter=',',
            fmt="%s")

          QtCore.QCoreApplication.instance().processEvents()

        for J in range(len(AnalysisData.inventoryAppliedError)):
          holder = headers.reshape((-1,1))
          holder = np.concatenate((holder,
            np.concatenate((AnalysisData.rawInventoryTimes[J].reshape((1,-1)),np.squeeze(AnalysisData.inventoryAppliedError[J])),axis=0,dtype='U13')),axis=1)

          np.savetxt(
            os.path.join(outdir,GUIparams.TestType+'_Inventory'+str(J)+'.csv'),
            holder.T,
            delimiter=',',
            fmt="%s")

          QtCore.QCoreApplication.instance().processEvents()

        for J in range(len(AnalysisData.outputAppliedError)):
          holder = headers.reshape((-1,1))
          holder = np.concatenate((holder,
            np.concatenate((AnalysisData.rawOutputTimes[J].reshape((1,-1)),np.squeeze(AnalysisData.outputAppliedError[J])),axis=0,dtype='U13')),axis=1)

          np.savetxt(
            os.path.join(outdir,GUIparams.TestType+'_Output'+str(J)+'.csv'),
            holder.T,
            delimiter=',',
            fmt="%s")

          QtCore.QCoreApplication.instance().processEvents()

      elif getOutType.clickedButton() == buttonCSVI:
        

        for J in range(IT): #IT

          h = []
          spacer = ['']

          for K in range(len(AnalysisData.inputAppliedError)):
            
            h.append(AnalysisData.rawInputTimes[K].tolist()) 
            h[-1].insert(0,'input'+str(K))
            h.append(np.squeeze(AnalysisData.inputAppliedError[K][J,]).tolist())
            h[-1].insert(0,'time')
            h.append(spacer)
            
          
          for K in range(len(AnalysisData.inventoryAppliedError)):

            h.append(AnalysisData.rawInventoryTimes[K].tolist()) 
            h[-1].insert(0,'inventory'+str(K))
            h.append(np.squeeze(AnalysisData.inventoryAppliedError[K][J,]).tolist())
            h[-1].insert(0,'time')
            h.append(spacer)
            
          
          for K in range(len(AnalysisData.outputAppliedError)):

            h.append(AnalysisData.rawOutputTimes[K].tolist()) 
            h[-1].insert(0,'output'+str(K))
            h.append(np.squeeze(AnalysisData.outputAppliedError[K][J,]).tolist())
            h[-1].insert(0,'time')
            h.append(spacer)
            


          # export_data = zip_longest(*h, fillvalue = None)
          # with open(os.path.join(outdir,GUIparams.TestType+'_Iteration'+str(J)+'.csv'), 'w', ) as myfile:
          #   wr = csv.writer(myfile)
          #   wr.writerows(export_data)

          with open(os.path.join(outdir,GUIparams.TestType+'_Iteration'+str(J)+'.csv'), 'w', ) as myfile:
            wr = csv.writer(myfile)
            for word in h:
              wr.writerow(word)

      elif getOutType.clickedButton() == buttonNPZ:
        
        
        #because of the headaches of ragged arrays it's easiest to store
        #at each location rather than per iteration (which is ideal), so
        #maybe this can be improved in the future


        
        for K in range(len(AnalysisData.inputAppliedError)):
            t = AnalysisData.rawInputTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.inputAppliedError[K])
            np.savez(os.path.join(outdir,GUIparams.TestType+'input'+str(K)+'.npz'),
            time = t,
            values = x)

        for K in range(len(AnalysisData.inventoryAppliedError)):
            t = AnalysisData.rawInventoryTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.inventoryAppliedError[K])
            np.savez(os.path.join(outdir,GUIparams.TestType+'inventory'+str(K)+'.npz'),
            time = t,
            values = x)

        for K in range(len(AnalysisData.outputAppliedError)):
            t = AnalysisData.rawOutputTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.outputAppliedError[K])
            np.savez(os.path.join(outdir,GUIparams.TestType+'output'+str(K)+'.npz'),
            time = t,
            values = x)




      elif getOutType.clickedButton() == buttonMAT:

        

        for K in range(len(AnalysisData.inputAppliedError)):
            t = AnalysisData.rawInputTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.inputAppliedError[K])
            mdict = {"time": t, "values": x}
            savemat(os.path.join(outdir,GUIparams.TestType+'input'+str(K)+'.mat'),mdict)

        for K in range(len(AnalysisData.inventoryAppliedError)):
            t = AnalysisData.rawInventoryTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.inventoryAppliedError[K])
            mdict = {"time": t, "values": x}
            savemat(os.path.join(outdir,GUIparams.TestType+'inventory'+str(K)+'.mat'),mdict)

        for K in range(len(AnalysisData.outputAppliedError)):
            t = AnalysisData.rawOutputTimes[K].reshape((1,-1))
            x = np.squeeze(AnalysisData.outputAppliedError[K])
            mdict = {"time": t, "values": x}
            savemat(os.path.join(outdir,GUIparams.TestType+'output'+str(K)+'.mat'),mdict)

      elif getOutType.clickedButton() == buttonPKL:

        for J in range(IT): #IT

          x = []
          t = []


          for K in range(len(AnalysisData.inputAppliedError)):
            
            t.append(AnalysisData.rawInputTimes[K].tolist()) 
            x.append(np.squeeze(AnalysisData.inputAppliedError[K][J,]).tolist())


            
          
          for K in range(len(AnalysisData.inventoryAppliedError)):

            t.append(AnalysisData.rawInventoryTimes[K].tolist()) 
            x.append(np.squeeze(AnalysisData.inventoryAppliedError[K][J,]).tolist())


            
          
          for K in range(len(AnalysisData.outputAppliedError)):

            t.append(AnalysisData.rawOutputTimes[K].tolist()) 
            x.append(np.squeeze(AnalysisData.outputAppliedError[K][J,]).tolist())

          with open(os.path.join(outdir,GUIparams.TestType+'_Iteration'+str(J)+'.pkl'), 'wb') as f:
            pickle.dump([x,t],f)

      else:
        None










    self.PB.setMaximum(100)
    self.PB.setValue(100)
    #self.StatDlg.UpdateDispText('Execution Finished')
    self.PB.setFormat('Execution finished')
    
def checkImportAxes(d):
  if d.shape[0] < d.shape[1]:
    np.swapaxes(d,0,1)
  
  return d

def getExtData(self,AnalysisData,GUIparams,Wizard):
  inpdict={"AnalysisData":AnalysisData, "GUIparams":GUIparams, "Wizard":Wizard}
  Q=queue.Queue()
  thread = ThreadTools.getExtData(Q,grabExt,parent=self)
  thread.start()
  Q.put(inpdict)

def grabExt(result):
  AnalysisData, GUIparams, Wizard, GUIObj, indat, inTdat, invdat, invTdat, outdat, outTdat = result

  AnalysisData.rawInput, AnalysisData.rawInputTimes, \
  AnalysisData.rawInventory, AnalysisData.rawInventoryTimes, \
  AnalysisData.rawOutput, AnalysisData.rawOutputTimes = indat, inTdat, invdat, invTdat, outdat, outTdat

  GUIparams.nInputLocations, GUIparams.nInventoryLocations, \
  GUIparams.nOutputLocations, GUIparams.nTotalLocations, \
  GUIparams.rowNames = processWizardGUI(AnalysisData,Wizard)
  GUIparams.ExtData = True



  GUIparams.nInferredEles = 1
  GUIparams.eleList = 'element0'

  StatsPanelOps.enable_setup_controls(GUIObj)


def processWizardGUI(AnalysisData,WizardObj):
  ninputloc = len(AnalysisData.rawInput)
  ninvloc = len(AnalysisData.rawInventory)
  noutloc = len(AnalysisData.rawOutput)
  ntotalloc = ninputloc + ninvloc + noutloc

  innames = []
  invnames = []
  outnames = []
  if len(WizardObj.InKMP_names) != ninputloc:
    for i in range(ninputloc):
      innames.append('input'+str(i))
  else:
    innames = WizardObj.InKMP_names
  
  if len(WizardObj.InvKMP_names) != ninvloc:
    for i in range(ninvloc):
      invnames.append('inventory'+str(i))
  else:
    invnames = WizardObj.InvKMP_names
  
  if len(WizardObj.OutKMP_names) != noutloc:
    for i in range(noutloc):
      outnames.append('output'+str(i))
  else:
    outnames = WizardObj.OutKMP_names

  spacer = ['']
  rownames = innames + spacer + invnames + spacer + outnames #lists


  return ninputloc, ninvloc, noutloc, ntotalloc, rownames



def getSceneData(GUIObj,AnalysisData,GUIparams):

  GUIObj.CB_ErrorProp.setEnabled(0)
  GUIObj.CB_ErrorProp.setChecked(1)
  GUIObj.IterBox.setEnabled(1)
  
  setnames = {
              "Normal": "Normal",
              "Abrupt Loss": "Abrupt",
              "Protracted Loss":"Protract"
            }

  mdl_names = {
                "Fuel Fab":"fuel_fab"
            }

  dirname, _ = os.path.split(os.path.abspath(__file__))
  x = Path(dirname).resolve().parents[0]
  F = os.path.join(x, 'data', mdl_names[GUIObj.mdlopts.currentText()], setnames[GUIObj.datopts.currentText()], 'data.mat')
  x1 = loadmat(F,squeeze_me=True)

  AnalysisData.rawInventory = x1['invn']['data']
  AnalysisData.rawInput = x1['in']['data']
  AnalysisData.rawOutput = x1['outn']['data']

  AnalysisData.rawInventoryTimes = x1['invn']['time']
  AnalysisData.rawInputTimes = x1['in']['time']
  AnalysisData.rawOutputTimes = x1['outn']['time']

  GUIparams.sceneName = GUIObj.mdlopts.currentText()
  GUIparams.nInputLocations = np.shape(AnalysisData.rawInput)[0]
  GUIparams.nInventoryLocations =  np.shape(AnalysisData.rawInventory)[0]
  GUIparams.nOutputLocations = np.shape(AnalysisData.rawOutput)[0]
  GUIparams.nTotalLocations = np.shape(AnalysisData.rawInput)[0] + np.shape(AnalysisData.rawInventory)[0] + np.shape(AnalysisData.rawOutput)[0]
  GUIparams.ExtData = False



  GUIparams.eleList = ['U']
  GUIparams.nInferredEles = 1

  #disable some checkboxes for fuel fab scenario
  #fuel fab only has uranium and some other
  #non actinide materials

  F = os.path.join(x, 'data', mdl_names[GUIObj.mdlopts.currentText()], setnames[GUIObj.datopts.currentText()], 'auxData.npz')
  A = np.load(F)
  GUIparams.rowNames = A['arr2']
  GUIObj.GESelector.addItem("U")
  #self.liH = ['U'] 
  GUIparams.eleList = ['U']
  GUIparams.nInferredEles = 1





  return AnalysisData, GUIparams


def loadGUILabels(GUIparams,international=False):
  if international == True:
      dictname = 'intLabels'
  else:
    dictname = 'domLabels'

  with open(os.path.join(str(Path(sys.argv[0]).resolve().parents[1]),'labels',dictname+'.json'),'r') as fp:
    labels = json.load(fp)

  with open(os.path.join(str(Path(sys.argv[0]).resolve().parents[1]),'labels','exemplarMdls'+'.json'),'r') as fp:
    GUIparams.availableMdls = json.load(fp)

  with open(os.path.join(str(Path(sys.argv[0]).resolve().parents[1]),'labels','exemplarDatas'+'.json'),'r') as fp:
    GUIparams.availableDatas = json.load(fp)

  GUIparams.labels = labels

  return GUIparams
